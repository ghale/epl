package org.epl.parser;

import java.util.Iterator;
import java.util.Set;

/* Generated By:JJTree: Do not edit this line. ASTForeach.java */

/**
 * Represents the Foreach production in the EPL grammar.
 * 
 * <pre>
 * Foreach ::= "foreach" &lt;ID&gt; "in" {@link ASTVarExpr VarExpr} {@link ASTBlock Block}
 * </pre> 
 * 
 * The first &lt;ID&gt; represents an individual item (a contained thing), such as event, that is part the second 
 * &lt;ID&gt;, a larger item (a containing thing), such as a collection of events.  The Block represents a block 
 * of code that will be executed, possibly multiple times. 
 * 
 * @see ASTBlock
 */
public class ASTForeach extends SimpleNode {
  String forEachContainedThing;
  
  public ASTForeach(int id) {
    super(id);
  }

  public ASTForeach(EplParser p, int id) {
    super(p, id);
  }
  
  /**
   * The intent of Foreach is to iterate over an {@link ASTBlock} a given number of times; the number of times
   * is the number of items in the "containing thing".  Over each iteration, an individual "contained thing" will 
   * be provided such that the Block can reference it. 
   */
  
  public void interpret() {
      super.interpret();
	  
      if (symtable.containsKeyLocal(forEachContainedThing)) 
    	  throw new RuntimeException("Duplicate variable declared in foreach statement: " + forEachContainedThing);
      jjtGetChild(0).interpret();
      Set<Object> set = null;
      try {
    	  set = (Set<Object>) stack.pop();
      } catch (ClassCastException e) {
    	  RuntimeException r = new RuntimeException("Invalid foreach: " + ((ASTVarExpr)jjtGetChild(0)).name + " is not a set!");
    	  r.initCause(e);
    	  throw r;
      }
      
      // Foreach() contains two identifiers and a single Block()
      // the Block() will need to be interpreted for each forEachContainedThing in forEachContainingThing
      // iterate through forEachContainingThing
      //   varying forEachContainedThing
      //   and calling
	  for (Iterator<Object> i=set.iterator(); i.hasNext();) {
		  symtable.putLocal(forEachContainedThing, i.next());
		  jjtGetChild(1).interpret();
		  symtable.removeLocal(forEachContainedThing);
	  }
  }

}
