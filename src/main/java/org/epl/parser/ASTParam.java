package org.epl.parser;

/* Generated By:JJTree: Do not edit this line. ASTParam.java */

/**
 * Represents the Param production in the EPL grammar.
 * <pre>
 * Param ::= {@link ASTVarExpr VarExpr}
 *         | &lt;STRING&gt;
 * </pre>
 * @see ASTVarExpr
 */
public class ASTParam extends SimpleNode {
  String literalString;
  public ASTParam(int id) {
    super(id);
  }

  public ASTParam(EplParser p, int id) {
    super(p, id);
  }
    
  /**
   * Interpret the {@link ASTVarExpr} child node as a string value, or return the literal value of the
   * &lt;STRING&gt; terminal, minus the leading and trailing quote marks 
   * @return the String result of evaluating the child node
   */
  public String interpretAsString() {
    // Param() production has either the single child VarExpr(), or a <STRING> terminal
    int i = jjtGetNumChildren();
    if (i > 0) {
      // VarExpr()
      return ((ASTVarExpr)jjtGetChild(0)).interpretAsString();
    } else {
      // <STRING>  with leading and trailing quote removed
      literalString = removeQuotes(literalString);
      return literalString;
    }
  }

  // Ridiculous hack because JVM seems to re-acquire the quotes from the string
  // when removed by replace, substring, etc and passed to Runtime.Exec()
  // Probably something to do with the underlying native libraries and efficiencies
  // built into String functions to reuse the underlying memory.
  // This still doesn't fix it - I'm stumped...this has to be a JVM bug
  private String removeQuotes(String original) {
	  StringBuffer s = new StringBuffer();
	  for (int i=1; i<original.length()-1; i++) {
		  s.append(original.charAt(i));
	  }
	  return s.toString();
  }
}
